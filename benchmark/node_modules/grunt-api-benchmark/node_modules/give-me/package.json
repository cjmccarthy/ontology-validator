{
  "name": "give-me",
  "version": "0.1.0",
  "description": "A simple js library to manage deferred functions with a callbacks-style syntax",
  "author": {
    "name": "Matteo Figus",
    "email": "matteofigus@gmail.com"
  },
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/matteofigus/give-me.git"
  },
  "bugs": {
    "url": "https://github.com/matteofigus/give-me/issues"
  },
  "keywords": [
    "async",
    "give me",
    "deferred",
    "callback",
    "promises",
    "parallel",
    "sequence"
  ],
  "main": "index",
  "engines": {
    "node": ">=0.8.x",
    "npm": ">=1.2.x"
  },
  "dependencies": {},
  "devDependencies": {
    "should": "2.1.1",
    "mocha": "1.16.2"
  },
  "scripts": {
    "test": "mocha"
  },
  "readme": "give-me [![Build Status](https://secure.travis-ci.org/matteofigus/give-me.png?branch=master)](http://travis-ci.org/matteofigus/give-me)\n=============\n\n[![NPM](https://nodei.co/npm/give-me.png?downloads=true)](https://npmjs.org/package/give-me)\n\n## How it works\n\nGive-me takes care of executing deferred functions in parallel/sequence, and allows you to use your functions exactly as they are keeping the well-known callback style. The only convention is that the callback arguments need to be the last in every function. The callback object is an array of callback results. \n\n## Installation\n\n```shell\nnpm install give-me\n```\n\n### all(functions [, arguments] [, maxConcurrency], callback)\n\nRuns an array of functions in parallel, and returns (with a callback) an array of callbacks in the same order when all the functions had been called.\n\n```js\nvar giveMe = require('give-me');\n\nvar a = function(callback){ setTimeout((function(){ callback('a'); }), 200); };\nvar b = function(callback){ setTimeout((function(){ callback('b'); }), 100); };\n\ngiveMe.all([a, b], function(result){\n\tconsole.log(result);\n\t// will display [['a'],['b']]\n});\n```\n\nIf functions need some parameters to work, they can be included in the optional \"arguments\" parameter. Just keep the callbacks in the end.\n\n```js\nvar giveMe = require('give-me');\n\nvar a = function(parameter1, parameter2, callback){ \n\tsetTimeout((function(){ \n\t\tcallback(parameter1 + ' ' + parameter2);\n\t}), 200); \n};\n\nvar b = function(parameter3, callback){ \n\tsetTimeout((function(){ \n\t\tcallback('hello', parameter3);\n\t}), 100); \n};\n\ngiveMe.all([a, b], [['hello', 'world'], ['hi']], function(result){\n\tconsole.log(result);\n\t// will display [['hello world'],['hello', 'hi']]\n});\n```\n\nWhen tuple argument provided it tries to return 2 arrays of results. In case the first array (supposed to be the errors) is an array of empty values it is nullified (so that callback is a function(x, y) => null, array).\n\n```js\nvar giveMe = require('give-me');\n\nvar errorFunc = function(callback){ \n\tsetTimeout((function(){ callback('error'); }), 200); \n};\n\nvar successFunc = function(callback){ \n\tsetTimeout((function(){  callback(null, 'hello'); }), 100); \n};\n\ngiveMe.all([errorFunc, successFunc], function(errors, results){\n\tconsole.log(errors); // will display ['error', null]\n\tconsole.log(results); // will display [null, 'hello'];\n});\n\ngiveMe.all([successFunc, successFunc], function(errors, results){\n\tconsole.log(errors); // will display null\n\tconsole.log(results); // will display ['hello', 'hello'];\n});\n```\n\n### any(functions [, arguments] [, conditionalFunction], callback)\n\t\nRuns an array of functions in parallel, but returns (with a callback) just the fastest, ignoring all the other callbacks.\n\n```js\nvar giveMe = require('give-me');\n\nvar a = function(callback){ setTimeout((function(){ callback('a'); }), 2000); };\nvar b = function(callback){ setTimeout((function(){ callback('b'); }), 100); };\n\ngiveMe.any([a, b], function(result){\n\tconsole.log(result);\n\t// will display ['[Not processed yet]',['b']]\n});\n```\n\t\nUsing the optional 'conditionalFunction' parameter the callback will be called when the fastest callback will satisfy a requirement provided through a sync function (in the example above, the 'c' function is the fastest that satisfies the condition, the callback for function b is anyway appended as processed before but it does not satisfies the requirement).\n\n```js\nvar giveMe = require('give-me');\n\nvar a = function(param, callback){ setTimeout((function(){ callback(param) }), 200); }\nvar b = function(param, callback){ setTimeout((function(){ callback(param) }), 50); }\nvar c = function(param, callback){ setTimeout((function(){ callback(param) }), 100); }\n\ngiveMe.any([a, b, c], [true, false, true], function(itemCallback){\n\treturn itemCallback[0] == true;\n}, function(result){\n\tconsole.log(result);\n\t// will display ['[Not processed yet]', [false], [true]]\n});\n```\n\n### sequence(functions [, arguments], callback)\n\nRuns an array of functions in sequence, and returns (with a callback) an array of callbacks in the same order when all the functions had been called. \n\n```js\nvar giveMe = require('give-me');\n\nvar a = function(callback){ setTimeout((function(){ callback('a'); }), 200); };\nvar b = function(callback){ setTimeout((function(){ callback('b'); }), 100); };\n\ngiveMe.sequence([a, b], function(result){\n\tconsole.log(result);\n\t// will display [['a'],['b']] after ~300ms\n});\n```\n\n## License\n\nMIT",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/matteofigus/give-me",
  "_id": "give-me@0.1.0",
  "dist": {
    "shasum": "940d93b38e079513f6230ee6ec6189e2e4fb670b"
  },
  "_from": "give-me@0.1.0",
  "_resolved": "https://registry.npmjs.org/give-me/-/give-me-0.1.0.tgz"
}
